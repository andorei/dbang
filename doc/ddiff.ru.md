# ddiff. Обнаружение расхождений в данных в двух БД

`ddiff` выполняет запросы к двум БД, сравнивает результаты и формирует html-отчет о найденных расхождениях.


* [Как это работает](#как-это-работает)
* [Исключение текущих изменений из отчета о расхождениях](#исключение-текущих-изменений-из-отчета-о-расхождениях)


## Как это работает

Чтобы проверить, одинаковы ли данные в двух БД, нужно извлечь данные из обеих и сравнить реузльтаты построчно, соединив их по первичному ключу. Но что если в таблицах БД содержатся десятки миллионов строк?

Существует трюк, позволяющий резко уменьшить количество строк, которые необходимо извлекать и сравнивать. Этот трюк - агрегирование.

Вместо извлечения миллионов строк из двух БД можно извлечь намного меньше агрегированных строк, полученных группировкой по выбранным столбцам. Затем сравнить два набора агрегированных строк и, в случае обнаружения расхождений, копнуть глубже (drill down) и найти строки в обеих БД, отвечающие за найденные расхождения.

Следующий пример иллюстрирует этот подход:

```
-- Вместо извлечения 20 миллионов строк с фактами продаж...

-- из базы данных #1 (Oracle)
select sale_date, pos_code, item_code, qty, amount from sales
;

-- и из базы данных #2 (PostgreSQL)
select tdate, pos_id, item_id, quantity, total from t_sales
;

-- извлечем строки, полученные группировкой по месяцу и точке продаж...

-- из базы данных #1 (Oracle)
select trunc(sale_date, 'mm') month,
    pos_code,
    count(*) count_,
    sum(item_code) sum_item,
    sum(qty) sum_qty,
    sum(amount) sum_amount
from sales
group by trunc(sale_date, 'mm'), pos_code
;

-- и из базы данных #2 (PostgreSQL)
select date_trunc('month', t_date) month,
    pos_id pos_code,
    count(*) count_,
    sum(item_id) sum_item,
    sum(quantity) sum_qty,
    sum(total) sum_amount
from t_sales
group by date_trunc('month', t_date), pos_id
;
```

Здесь строки исходных таблиц группируются по дате первого дня месяца, в котором произошла продажа, и коду торговой точки (point of sales). Это же сочетание `(month, pos_code)` является уникальным идентификатором (первичным ключом) для результирующих наборов строк.

Имея два набора строк, мы можем найти строки из набора #1, отсутствующие в наборе #2, и строки из набора #2, отсутствующие в наборе #1. Предположим, таковыми оказались следующие строки:

```
-- строки из набора #1, отсутствующие в наборе #2
month      pos_code count_ sum_item sum_qty sum_amount
---------- -------- ------ -------- ------- ----------
2023-03-01       52  13140 10230677    4089    5235670

-- строки из набора #2, отсутствующие в наборе #1
month      pos_code count_ sum_item sum_qty sum_amount
---------- -------- ------ -------- ------- ----------
2023-03-01       52  13140 10230677    4088    5235635
```

Как видим, строки из двух наборов с агрегированными продажами за март 2023 на точке 52 отличаются столбцами `sum_qty` и `sum_amount`. Данные продаж по другим месяцам и точкам продаж не имеют расхождений.

Чтобы найти отличающиеся строки в двух БД нужно выбрать строки только для месяцев и точек продаж, для которых есть расхождения агрегированных строк. Понадобится извлечь около 13140 строк из каждой БД (см. столбец `count_`) и сравнить их.

```
-- из базы данных #1 (Oracle)
select sale_date,
    pos_code,
    item_code,
    qty,
    amount
from sales
where (trunc(sale_date, 'mm'), pos_code) in (
        (date '2023-03-01', 52)
    )
;

-- и из базы данных #2 (PostgreSQL)
select t_date sale_date,
    pos_id pos_code,
    item_id item_code,
    quantity qty,
    total amount
from t_sales
where (date_trunc('month', t_date), pos_id) in (
        (date '2023-03-01', 52)
    )
;
```

Первичные ключи результирующих наборов строк - сочетание `(sale_date, pos_code, item_code)`. 

И вновь, имея два набора строк, мы можем найти строки из набора #1, отсутствующие в наборе #2, и строки из набора #2, отсутствующие в наборе #1. Таковыми оказываются следующие строки:

```
-- строки из набора #1, отсутствующие в наборе #2
sale_date  pos_code item_code qty amount
---------- -------- --------- --- ------
2023-03-25       52     66156   2     70

-- строки из набора #2, отсутствующие в наборе #1
sale_date  pos_code item_code qty amount
---------- -------- --------- --- ------
2023-03-25       52     66156   1     35
```

Вот и все. Согласно БД #1, 25 марта 2023 на точке 52 продано 2 товара 66156 на общую сумму 70, а согласно БД #2 - только 1 товар на общую сумму 35.

Соединим строки по первичному ключу `(sale_date, pos_code, item_code)`, чтобы наглядно представить расхождения для отчета:

```
sale_date  pos_code item_code qty#1 qty#2 amount#1 amount#2
---------- -------- --------- ----- ----- -------- --------
2023-03-25       52     66156     2     1       70       35
```

Ниже пример конфиг-файла со спецификацией, использующей рассмотренные запросы (с незначительными изменениями):

```
import os
import sys

from sources import sources


# MANDATORY constants used by ddiff.py

# Directory where discrepancies report is saved
OUT_DIR = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'out')

# DB where intermediate data is kept and processed
DDIFF_SOURCE = sources['sqlite-source']


specs = {
    "sales": {
        "sources": ["prod", "whs"],
        "queries": [
            """
            select trunc(sale_date, 'mm') month,
                pos_code,
                count(*) count_,
                sum(item_code) sum_item,
                sum(qty) sum_qty,
                sum(amount) sum_amount
            from sales
            group by trunc(sale_date, 'mm'), pos_code
            """,
            """
            select date_trunc('month', t_date) month,
                pos_id pos_code,
                count(*) count_,
                sum(item_id) sum_item,
                sum(quantity) sum_qty,
                sum(total) sum_amount
            from t_sales
            group by date_trunc('month', t_date), pos_id
            """
        ],
        "pk": ["month", "pos_code"],
        #
        # level 2
        #
        "sales": {
            "queries": [
                """
                select sale_date,
                    pos_code,
                    item_code,
                    qty,
                    amount
                from sales
                where (trunc(sale_date, 'mm'), pos_code) in (
                    {% for row in argrows %}(date '{{row[0]}}', {{row[1]}}){{"," if not loop.last}}{% endfor %}
                    )
                """,
                """
                select t_date sale_date,
                    pos_id pos_code,
                    item_id item_code,
                    quantity qty,
                    total amount
                from t_sales
                where (date_trunc('month', t_date), pos_id) in (
                    {% for row in argrows %}(date '{{row[0]}}', {{row[1]}}){{"," if not loop.last}}{% endfor %}
                    )
                """
            ],
            "pk": ["sale_date", "pos_code", "item_code"]
        }
    }
}
```

Тексты запросов в спецификации являются jinja2-шаблонами. Перед выполнением запросов уровня 2 шаблоны обрабатываются, чтобы формировать списки (дата, код точки продаж) для оператора `in` в части `where`. Переменная `argrows` содержит строки с расхождениями, найденные с помощью запросов верхнего уровня.

В спецификации можно указать столько уровней агрегирования, сколько представляется оптимальным. Чем больше уровней вы определите, тем меньше строк будет извлекаться из баз данных на каждом уровне.

Глобальная переменная `OUT_DIR` в конфиг-файле задает директорию, в которой формируется отчет о расхождениях.

В тестовых конфиг-файлах `ddiff-test-<source>.py` вы найдете комментарии к каждому из параметров спецификации. Познакомьтесь с ними, чтобы составить исчерпывающее представление обо всех параметрах и их назначении.


## Исключение текущих изменений из отчета о расхождениях

Зачастую сложно или невозможно выбрать время суток, когда данные в БД не изменяются. На распространение изменений из одной БД в другую требуется некоторе время, от минут до часов. В таком случае, сравнивая результаты запросов к двум БД, мы всегда обнаруживаем расхождения, поскольку самые недавние изменения находятся в пути от одной БД к другой.

Чтобы исключить попадание текущих изменений в отчет о расхождениях, реализован следующий экспериментальный подход:

1. выполнить чувствительную к текущим изменениям спецификацию конфиг-файла два раза с интервалом, превышающим интервал распространения измененй из одной БД в другую, и
2. включить в отчет только расхождения, найденные и обоих случаях и совпадающие по значениям.

Расхождения, которые были найдены при первом выполнении спецификации и не найдены при втором выполнении, связаны с текущими изменениями, которые были в пути на момент первого выполнения. Расхождения, найденные при втором выполнении спецификации, которых не было первом выполнении, считаются текущими изменениями, которые находятся в пути на момент второго выполнения. И только расхождения, найденные и при первом и при втором выполнении спецификации, считаются проблемными.

Данный сценарий реализуется с помощью опций командной строки `ddiff`:

```
-1, --one      find discrepancies and store them
-2, --two      find discrepancies and intersect them with the stored
```

Для иллюстрации воспользуемся спецификацией `"current"` для БД sqlite (функция `datetime` во втором запросе специфична для sqlite):

```
spec = {
    "current": {
        "sources": ["ONE", "TWO"],
        "pk": ["c1"],
        "queries": [
            """
            select 1 c1, current_timestamp c2, 3 c3 from dual
            union all
            select 2 c1, current_timestamp c2, 5 c3 from dual
            union all
            select 3 c1, current_timestamp c2, 7 c3 from dual
            union all
            select 5 c1, current_timestamp c2, 1 c3 from dual
            """,
            """
            select 1 c1, datetime(current_timestamp, '+5 second') c2, 3 c3 from dual
            union all
            select 2 c1, current_timestamp c2, 6 c3 from dual
            union all
            select 4 c1, current_timestamp c2, 9 c3 from dual
            union all
            select 5 c1, current_timestamp c2, 1 c3 from dual
            """
       ]
    },
    ...
}
```

Выполнив спецификацию в обычном режиме, получим следующий отчет о расхождениях:

```
c1 DB1 c2              DB2 c2              DB1 c3 DB2 c3
-- ------------------- ------------------- ------ ------
 1 2023-08-29 04:20:18 2023-08-29 04:20:23      3      3
 2 2023-08-29 04:20:18 2023-08-29 04:20:18      5      6
 3 2023-08-29 04:20:18 [NULL]                   7 [NULL]
 4 [NULL]              2023-08-29 04:20:18 [NULL]      9
```

Обратите внимание, что расхождение в строке с `c1 = 1` возникает из-за того, что в запросе к БД `ONE` значение столбца `c2` есть текущее время, а в запросе к БД `TWO` – текущее время плюс 5 секунд. Следовательно, сколько бы раз мы ни выполняли запросы, мы будем получать разные значения в столбце `c2` – так как время идет. Кроме того, строки с `c1 = 1`, возвращаемые запросами к БД `ONE` и БД `TWO` будут различаться на 5 секунд. Это имитация ситуации с текущими изменениями "в пути".

Теперь выполним спецификацию в режиме устранения текущих изменений. Первый проход:

```
ddiff.py -1 ddiff-test-sqlite current
```

И второй проход:

```
ddiff.py -2 ddiff-test-sqlite current
```

Второй проход сформировал следующий отчет о расхождениях:

```
c1 DB1 c2              DB2 c2              DB1 c3 DB2 c3
-- ------------------- ------------------- ------ ------
 2 2023-08-29 04:22:36 2023-08-29 04:22:36      5      6
 3 2023-08-29 04:22:36 [NULL]                   7 [NULL]
 4 [NULL]              2023-08-29 04:22:36 [NULL]      9
```

Строка с `с1 = 1` исключена из отчета о расхождениях, так как в 1-м и во 2-м проходах были найдены различные расхождения в столбце `c2` этой строки, что говорит о текущих изменениях в этой строке. Тогда как строки 2, 3 и 4 продемонстрировали повторяющиеся расхождения в обоих проходах, а строка 5 не имеет расхождений.
