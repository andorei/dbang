# ddiff. Обнаружение расхождений в данных в двух БД

	версия 0.3

`ddiff` выполняет запросы к двум БД, сравнивает результаты и формирует html-отчет о найденных расхождениях.

* [Как это работает](#как-это-работает)
* [Обнаружение расхождений за два прохода](#обнаружение-расхождений-за-два-прохода)
* [Аргументы командной строки](#аргументы-командной-строки)
* [Параметры конфиг-файла](#параметры-конфиг-файла)
* [Параметры спецификации](#параметры-спецификации)

## Как это работает

Чтобы проверить, одинаковы ли данные в двух БД, нужно извлечь данные из обеих и сравнить результаты построчно, соединив их по первичному ключу. Но что если в таблицах БД содержатся десятки миллионов строк?

Существует трюк, позволяющий резко уменьшить количество строк, которые необходимо извлекать и сравнивать. Этот трюк - агрегирование.

Вместо извлечения миллионов строк из двух БД можно извлечь намного меньше агрегированных строк, полученных группировкой по выбранным столбцам. Затем сравнить два набора агрегированных строк и, в случае обнаружения расхождений, копнуть глубже (drill down) и найти строки в обеих БД, отвечающие за найденные расхождения.

Следующий пример иллюстрирует этот подход:

```
-- Вместо извлечения 20 миллионов строк с фактами продаж...

-- из базы данных #1 (Oracle)
select sale_date, pos_code, item_code, qty, amount from sales
;

-- и из базы данных #2 (PostgreSQL)
select tdate, pos_id, item_id, quantity, total from t_sales
;

-- извлечем строки, полученные группировкой по месяцу и точке продаж...

-- из базы данных #1 (Oracle)
select trunc(sale_date, 'mm') month,
    pos_code,
    count(*) count_,
    sum(item_code) sum_item,
    sum(qty) sum_qty,
    sum(amount) sum_amount
from sales
group by trunc(sale_date, 'mm'), pos_code
;

-- и из базы данных #2 (PostgreSQL)
select date_trunc('month', t_date) month,
    pos_id pos_code,
    count(*) count_,
    sum(item_id) sum_item,
    sum(quantity) sum_qty,
    sum(total) sum_amount
from t_sales
group by date_trunc('month', t_date), pos_id
;
```

Здесь строки исходных таблиц группируются по дате первого дня месяца, в котором произошла продажа, и коду торговой точки (point of sales). Это же сочетание `(month, pos_code)` является уникальным идентификатором (первичным ключом) для результирующих наборов строк.

Имея два набора строк, мы можем найти строки из набора #1, отсутствующие в наборе #2, и строки из набора #2, отсутствующие в наборе #1. Предположим, таковыми оказались следующие строки:

```
-- строки из набора #1, отсутствующие в наборе #2
month      pos_code count_ sum_item sum_qty sum_amount
---------- -------- ------ -------- ------- ----------
2023-03-01       52  13140 10230677    4089    5235670

-- строки из набора #2, отсутствующие в наборе #1
month      pos_code count_ sum_item sum_qty sum_amount
---------- -------- ------ -------- ------- ----------
2023-03-01       52  13140 10230677    4088    5235635
```

Как видим, строки из двух наборов с агрегированными продажами за март 2023 на точке 52 отличаются столбцами `sum_qty` и `sum_amount`. Данные продаж по другим месяцам и точкам продаж не имеют расхождений.

Чтобы найти отличающиеся строки в двух БД нужно выбрать строки только для месяцев и точек продаж, для которых есть расхождения агрегированных строк. Понадобится извлечь около 13140 строк из каждой БД (см. столбец `count_`) и сравнить их.

```
-- из базы данных #1 (Oracle)
select sale_date,
    pos_code,
    item_code,
    qty,
    amount
from sales
where (trunc(sale_date, 'mm'), pos_code) in (
        (date '2023-03-01', 52)
    )
;

-- и из базы данных #2 (PostgreSQL)
select t_date sale_date,
    pos_id pos_code,
    item_id item_code,
    quantity qty,
    total amount
from t_sales
where (date_trunc('month', t_date), pos_id) in (
        (date '2023-03-01', 52)
    )
;
```

Первичные ключи результирующих наборов строк - сочетание `(sale_date, pos_code, item_code)`. 

И вновь, имея два набора строк, мы можем найти строки из набора #1, отсутствующие в наборе #2, и строки из набора #2, отсутствующие в наборе #1. Таковыми оказываются следующие строки:

```
-- строки из набора #1, отсутствующие в наборе #2
sale_date  pos_code item_code qty amount
---------- -------- --------- --- ------
2023-03-25       52     66156   2     70

-- строки из набора #2, отсутствующие в наборе #1
sale_date  pos_code item_code qty amount
---------- -------- --------- --- ------
2023-03-25       52     66156   1     35
```

Вот и все. Согласно БД #1, 25 марта 2023 на точке 52 продано 2 товара 66156 на общую сумму 70, а согласно БД #2 - только 1 товар на общую сумму 35.

Соединим строки по первичному ключу `(sale_date, pos_code, item_code)`, чтобы наглядно представить расхождения для отчета:

```
sale_date  pos_code item_code qty#1 qty#2 amount#1 amount#2
---------- -------- --------- ----- ----- -------- --------
2023-03-25       52     66156     2     1       70       35
```

Ниже пример конфиг-файла со спецификацией, использующей рассмотренные запросы (с незначительными изменениями):

```
import os
import sys

from sources import sources


# MANDATORY constants used by ddiff.py

# Directory where discrepancies report is saved
OUT_DIR = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'out')

# DB where intermediate data is kept and processed
DDIFF_SOURCE = sources['sqlite-source']


specs = {
    "sales": {
        "sources": ["prod", "whs"],
        "queries": [
            """
            select trunc(sale_date, 'mm') month,
                pos_code,
                count(*) count_,
                sum(item_code) sum_item,
                sum(qty) sum_qty,
                sum(amount) sum_amount
            from sales
            group by trunc(sale_date, 'mm'), pos_code
            """,
            """
            select date_trunc('month', t_date) month,
                pos_id pos_code,
                count(*) count_,
                sum(item_id) sum_item,
                sum(quantity) sum_qty,
                sum(total) sum_amount
            from t_sales
            group by date_trunc('month', t_date), pos_id
            """
        ],
        "pk": ["month", "pos_code"],
        #
        # level 2
        #
        "sales": {
            "queries": [
                """
                select sale_date,
                    pos_code,
                    item_code,
                    qty,
                    amount
                from sales
                where (trunc(sale_date, 'mm'), pos_code) in (
                    {% for row in argrows %}(date '{{row[0]}}', {{row[1]}}){{"," if not loop.last}}{% endfor %}
                    )
                """,
                """
                select t_date sale_date,
                    pos_id pos_code,
                    item_id item_code,
                    quantity qty,
                    total amount
                from t_sales
                where (date_trunc('month', t_date), pos_id) in (
                    {% for row in argrows %}(date '{{row[0]}}', {{row[1]}}){{"," if not loop.last}}{% endfor %}
                    )
                """
            ],
            "pk": ["sale_date", "pos_code", "item_code"]
        }
    }
}
```

Тексты запросов в спецификации являются jinja2-шаблонами. Перед выполнением запросов уровня 2 шаблоны обрабатываются, чтобы формировать списки (дата, код точки продаж) для оператора `in` в части `where`. Переменная `argrows` содержит строки с расхождениями, найденные с помощью запросов верхнего уровня.

В спецификации можно указать столько уровней агрегирования, сколько представляется оптимальным. Чем больше уровней вы определите, тем меньше строк будет извлекаться из баз данных на каждом уровне.

Глобальная переменная `OUT_DIR` в конфиг-файле задает директорию, в которой формируется отчет о расхождениях.

В тестовых конфиг-файлах `ddiff-test-<source>.py` вы найдете комментарии к каждому из параметров спецификации. Познакомьтесь с ними, чтобы составить исчерпывающее представление обо всех параметрах и их назначении.

## Обнаружение расхождений за два прохода

Зачастую сложно или невозможно выбрать время суток, когда данные в БД не изменяются. На распространение изменений из одной БД в другую требуется некоторе время, от минут до часов. В таком случае, сравнивая результаты запросов к двум БД, мы всегда обнаруживаем расхождения, поскольку самые недавние изменения находятся в пути от одной БД к другой.

Чтобы исключить попадание текущих изменений в отчет о расхождениях, реализован следующий экспериментальный подход:

1. выполнить чувствительную к текущим изменениям спецификацию конфиг-файла два раза с интервалом, превышающим интервал распространения измененй из одной БД в другую, и
2. включить в отчет только расхождения, найденные и обоих случаях и совпадающие по значениям.

Расхождения, которые были найдены при первом выполнении спецификации и не найдены при втором выполнении, связаны с текущими изменениями, которые были в пути на момент первого выполнения. Расхождения, найденные при втором выполнении спецификации, которых не было первом выполнении, считаются текущими изменениями, которые находятся в пути на момент второго выполнения. И только расхождения, найденные и при первом и при втором выполнении спецификации, считаются проблемными.

Данный сценарий реализуется с помощью опций командной строки `ddiff`:

```
-1, --one      find discrepancies and store them
-2, --two      find discrepancies and intersect them with the stored
```

Для иллюстрации воспользуемся спецификацией `"current"` для БД sqlite (функция `datetime` во втором запросе специфична для sqlite):

```
spec = {
    "current": {
        "sources": ["ONE", "TWO"],
        "pk": ["c1"],
        "queries": [
            """
            select 1 c1, current_timestamp c2, 3 c3 from dual
            union all
            select 2 c1, current_timestamp c2, 5 c3 from dual
            union all
            select 3 c1, current_timestamp c2, 7 c3 from dual
            union all
            select 5 c1, current_timestamp c2, 1 c3 from dual
            """,
            """
            select 1 c1, datetime(current_timestamp, '+5 second') c2, 3 c3 from dual
            union all
            select 2 c1, current_timestamp c2, 6 c3 from dual
            union all
            select 4 c1, current_timestamp c2, 9 c3 from dual
            union all
            select 5 c1, current_timestamp c2, 1 c3 from dual
            """
       ]
    },
    ...
}
```

Выполнив спецификацию в обычном режиме, получим следующий отчет о расхождениях:

```
c1 DB1 c2              DB2 c2              DB1 c3 DB2 c3
-- ------------------- ------------------- ------ ------
 1 2023-08-29 04:20:18 2023-08-29 04:20:23      3      3
 2 2023-08-29 04:20:18 2023-08-29 04:20:18      5      6
 3 2023-08-29 04:20:18 [NULL]                   7 [NULL]
 4 [NULL]              2023-08-29 04:20:18 [NULL]      9
```

Обратите внимание, что расхождение в строке с `c1 = 1` возникает из-за того, что в запросе к БД `ONE` значение столбца `c2` есть текущее время, а в запросе к БД `TWO` – текущее время плюс 5 секунд. Следовательно, сколько бы раз мы ни выполняли запросы, мы будем получать разные значения в столбце `c2` – так как время идет. Кроме того, строки с `c1 = 1`, возвращаемые запросами к БД `ONE` и БД `TWO` будут различаться на 5 секунд. Это имитация ситуации с текущими изменениями "в пути".

Теперь выполним спецификацию в режиме устранения текущих изменений. Первый проход:

```
ddiff.py -1 ddiff-test-sqlite current
```

И второй проход:

```
ddiff.py -2 ddiff-test-sqlite current
```

Второй проход сформировал следующий отчет о расхождениях:

```
c1 DB1 c2              DB2 c2              DB1 c3 DB2 c3
-- ------------------- ------------------- ------ ------
 2 2023-08-29 04:22:36 2023-08-29 04:22:36      5      6
 3 2023-08-29 04:22:36 [NULL]                   7 [NULL]
 4 [NULL]              2023-08-29 04:22:36 [NULL]      9
```

Строка с `с1 = 1` исключена из отчета о расхождениях, так как в 1-м и во 2-м проходах были найдены различные расхождения в столбце `c2` этой строки, что говорит о текущих изменениях в этой строке. Тогда как строки 2, 3 и 4 продемонстрировали повторяющиеся расхождения в обоих проходах, а строка 5 не имеет расхождений.

## Аргументы командной строки

```
$ ./ddiff.py -h
usage: ddiff.py [-h] [-v] [-1] [-2] cfg_file [spec]

Detect discrepancies in two databases as specified in cfg-file specs.

positional arguments:
  cfg_file       cfg-file name
  spec           spec name, defaults to "all"

options:
  -h, --help     show this help message and exit
  -v, --version  show program's version number and exit
  -1, --one      find discrepancies and store them
  -2, --two      find discrepancies and intersect them with the stored

Thanks for using ddiff.py!
```

Обязательно только имя конфиг-файла `cfg_file`.

Если задано имя спецификации `spec`, то выполняется указанная спецификация. Иначе – все спецификации из конфиг-файла.

О ключах `--one` и `--two` см. [Обнаружение расхождений за два прохода](#обнаружение-расхождений-за-два-прохода).

## Параметры конфиг-файла

Параметры конфиг-файла суть переменные с именами в верхнем регистре, задающие контекст для выполнения спецификаций из данного конфиг-файла. См. также [Структура конфиг-файлов](conf.ru.md).

Параметры конфиг-файла для `ddiff` приведены ниже.

| Параметр          | Значение по умолчанию   | Описание                                                                                       |
| ----------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |
| `DEBUGGING`       | `False`                 | Режим отладки?                                                                                 |
| `LOGGING`         | = DEBUGGING             | Писать в лог-файл?                                                                             |
| `LOG_DIR`         | `./`                    | Директория для лог-файлов.                                                                     |
| `OUT_DIR`         | `./`                    | Директория для файлов отчетов о расхождениях.                                                  |
| `DATETIME_FORMAT` | `"%Y-%m-%d %H:%M:%S%z"` | Формат даты и времени; по умолчанию ISO 86101.                                                 |
| `DATE_FORMAT`     | `"%Y-%m-%d"`            | Формат даты; по умолчанию ISO 86101.                                                           |
| `SOURCES`*        |                         | Необязательный список (list) имен двух источников данных, определенных в файле `sources.py`. |
\* параметр конфиг-файла, помеченный звездочкой, на уровне спецификации может быть переопределен соответствующим параметром спецификации.

## Параметры спецификации

 Спецификации находятся в конфиг-файле в словаре (dict) `specs` и содержат  **параметры спецификации**. См. также [Структура конфиг-файлов](conf.ru.md).

Параметры спецификации для `ddiff` приведены ниже. Если специально не оговорено, то параметр спецификации является необязательным и может быть опущен.

| Параметр спецификации | Описание                                                                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `"tags"`              | Список (list) тегов для выбора данной спецификации в командной строке.                                                                                                                                                 |
| `"sources"`           | Список (list) имен двух источников данных (далее DB1 и DB2), определенных в файле `sources.py`. Если не задан, то используется параметр конфиг-файла `SOURCES`.                                                        |
| `"doc"`               | Краткое описание/комментарий к спецификации, отображаемое в отчете о расхождениях.                                                                                                                                       |
| `"setups"`            | Список (list) предложений SQL для DB1 и DB2, выполняемых в начале выполнения спецификации.                                                                                                                             |
| `"upsets"`            | Список (list) предложений SQL для DB1 и DB2, выполняемых при завершении спецификации.                                                                                                                                  |
| **`"queries"`**       | **ОБЯЗАТЕЛЬНЫЙ** список (list) двух запросов `select` для DB1 и DB2, соответственно. Два запроса должны возвращать столбцы с одинаковыми именами и типами данных, чтобы можно было определить разность их результатов. |
| **`"pk"`**            | **ОБЯЗАТЕЛЬНЫЙ** список (list) имен столбцов, составляющих "первичный ключ" результатов запроса `"queries"`.                                                                                                           |
| `"op"`                | Модификатор разности, принимающий значения `>` (разность данных DB1 и DB2), `<` (разность данных DB2 и DB1) или `=` (симметричная разность, по умолчанию).                                                               |
| `"<spec>"`            | Словарь (dict) с обязательными ключами `queries` и `pk`, определяющий запросы и "первичный ключ" уровня 2. Может содержать необязательный словарь `<spec>` следующего уровня вложенности.                              |
